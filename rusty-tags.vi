!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
Add	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b> Add<&'b Word<'a>> for &'b Word<'a> {$/;"	i
BitAnd	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b> BitAnd<&'b Word<'a>> for &'b Word<'a> {$/;"	i
BitXor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b> BitXor<&'b Word<'a>> for &'b Word<'a> {$/;"	i
Cache	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^impl Cache {$/;"	i
CachingStrategy	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^pub trait CachingStrategy<I, O> {$/;"	t
CompressiveSensing	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^impl<X, Y> CompressiveSensing<X, Y>$/;"	i
CompressiveSensing	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^pub struct CompressiveSensing<X, Y> {$/;"	s
Debug for Forest	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^impl Debug for Forest {$/;"	i
Debug for Memoize	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^impl<I, O, S> Debug for Memoize<I, O, S>$/;"	i
Default for NodeHasherState	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^impl Default for NodeHasherState {$/;"	i
Fn	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b, 'c> Fn<(&'b HashSet<Variable>,)> for Word<'a> {$/;"	i
FnMut	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b, 'c> FnMut<(&'b HashSet<Variable>,)> for Word<'a> {$/;"	i
FnOnce	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b, 'c> FnOnce<(&'b HashSet<Variable>,)> for Word<'a> {$/;"	i
Forest	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^impl Forest {$/;"	i
Forest	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^pub struct Forest {$/;"	s
HashState for NodeHasherState	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^impl HashState for NodeHasherState {$/;"	i
Hasher	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    type Hasher = NodeHasher;$/;"	T
Hasher for NodeHasher	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^impl Hasher for NodeHasher {$/;"	i
Memoize	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^impl<I, O, S> Memoize<I, O, S>$/;"	i
Memoize	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^pub struct Memoize<I: Hash + Eq, O, S> {$/;"	s
Node	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^pub struct Node(pub Variable, pub NodeIdx, pub NodeIdx);$/;"	s
NodeHasher	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^impl NodeHasher {$/;"	i
NodeHasher	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^pub struct NodeHasher {$/;"	s
NodeHasherState	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^impl NodeHasherState {$/;"	i
NodeHasherState	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^pub struct NodeHasherState;$/;"	s
NodeIdx	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^pub type NodeIdx = usize;$/;"	T
NodePage	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^impl NodePage {$/;"	i
NodePage	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^struct NodePage {$/;"	s
Not	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b> Not for &'b Word<'a> {$/;"	i
Output	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    type Output = Word<'a>;$/;"	T
Output	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    type Output = u32;$/;"	T
ProjectionState	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^impl ProjectionState {$/;"	i
ProjectionState	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^struct ProjectionState;$/;"	s
Shr	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a, 'b> Shr<usize> for &'b Word<'a> {$/;"	i
Variable	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^pub type Variable = u8;$/;"	T
Word	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^impl<'a> Word<'a> {$/;"	i
Word	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^pub struct Word<'a> {$/;"	s
add	/Users/blaxill/code/github.com/blaxill/boo/src/add.rs	/^pub fn add(f: &mut Forest,$/;"	f
add	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod add;$/;"	m
add	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn add(self, other: &Word<'a>) -> Word<'a> {$/;"	f
add_basic	/Users/blaxill/code/github.com/blaxill/boo/src/add.rs	/^    fn add_basic() {$/;"	f
approximate_jacobian	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    pub fn approximate_jacobian(&self) -> Box<Fn(u32)->u32 + 'a> {$/;"	f
bench_10_sparse_64_add	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_10_sparse_64_add(b: &mut Bencher) {$/;"	f
bench_10_sparse_64_xor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_10_sparse_64_xor(b: &mut Bencher) {$/;"	f
bench_12_sparse_64_xor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_12_sparse_64_xor(b: &mut Bencher) {$/;"	f
bench_8_sparse_64_add	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_8_sparse_64_add(b: &mut Bencher) {$/;"	f
bench_8_sparse_64_xor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_8_sparse_64_xor(b: &mut Bencher) {$/;"	f
bench_k_sparse_64_add	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_k_sparse_64_add(b: &mut Bencher, k: usize) {$/;"	f
bench_k_sparse_64_xor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bench_k_sparse_64_xor(b: &mut Bencher, k: usize) {$/;"	f
bitand	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bitand(self, other: &Word<'a>) -> Word<'a> {$/;"	f
bitxor	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn bitxor(self, other: &Word<'a>) -> Word<'a> {$/;"	f
call	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    extern "rust-call" fn call(&self, args: (&'b HashSet<Variable>,)) -> u32 {$/;"	f
call_mut	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    extern "rust-call" fn call_mut(&mut self, args: (&'b HashSet<Variable>,)) -> u32 {$/;"	f
call_once	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    extern "rust-call" fn call_once(self, (variable_map,): (&'b HashSet<Variable>,)) -> u32 {$/;"	f
compress	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^pub fn compress(cache: &mut Cache,$/;"	f
compressive_sensing	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^    pub fn compressive_sensing<T, U>($/;"	f
compressive_sensing	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^pub fn compressive_sensing<'a, Transform, V>($/;"	f
compressive_sensing	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod compressive_sensing;$/;"	m
constant	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    pub fn constant(forest: &RefCell<Forest>, value: u32) -> Word {$/;"	f
default	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    fn default() -> NodeHasherState {$/;"	f
degree	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn degree(&self, idx: NodeIdx) -> usize {$/;"	f
delta	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^fn delta<'a>(target: &Vec<Word<'a>>, current: Vec<Word<'a>>) -> Vec<Word<'a>> {$/;"	f
enforce_sparsity	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn enforce_sparsity(&mut self, idx: NodeIdx, new_sparsity: usize)$/;"	f
evaluate	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn evaluate(&self, idx: NodeIdx,$/;"	f
finish	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    fn finish(&self) -> u64 {$/;"	f
fmt	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    fn fmt(&self, f :&mut Formatter) -> Result<(), Error> {$/;"	f
fmt	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {$/;"	f
forest	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod forest;$/;"	m
forest_basic	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    fn forest_basic() {$/;"	f
from_fn	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    pub fn from_fn<F>(forest: &RefCell<Forest>, mut func: F) -> Word$/;"	f
get	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^    fn get(&\/*mut*\/self, input: &I) -> Option<&O>;$/;"	f
get	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^    pub fn get(&mut self, input: &I) -> Option<O> {$/;"	f
get_or_insert	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    fn get_or_insert(&mut self, hi: NodeIdx, lo: NodeIdx, next_free: NodeIdx) -> NodeIdx {$/;"	f
hasher	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    fn hasher(&self) -> NodeHasher {$/;"	f
minmax	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^pub fn minmax<T: Ord>(lhs: T, rhs: T) -> (T, T) {$/;"	f
multiply	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod multiply;$/;"	m
multiply	/Users/blaxill/code/github.com/blaxill/boo/src/multiply.rs	/^pub fn multiply(f: &mut Forest,$/;"	f
multiply_basic	/Users/blaxill/code/github.com/blaxill/boo/src/multiply.rs	/^    fn multiply_basic() {$/;"	f
multiply_with_sparsity	/Users/blaxill/code/github.com/blaxill/boo/src/multiply.rs	/^pub fn multiply_with_sparsity(f: &mut Forest,$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^    fn new(sparsity: usize) -> ProjectionState { ProjectionState }$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^    pub fn new(sparsity: usize, initial: X, target: Y) -> CompressiveSensing<X, Y> {$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    fn new() -> NodePage {$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn new() -> Forest {$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^    pub fn new() -> Cache {$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^    pub fn new() -> Memoize<I, O, S> { $/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    pub fn new() -> NodeHasher { NodeHasher{ val: 0 } }$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    pub fn new() -> NodeHasherState { NodeHasherState }$/;"	f
new	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    pub fn new(forest: &RefCell<Forest>) -> Word {$/;"	f
node_hasher	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod node_hasher;$/;"	m
not	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn not(self) -> Word<'a> {$/;"	f
restrict	/Users/blaxill/code/github.com/blaxill/boo/src/compressive_sensing.rs	/^    fn restrict<'a>(&self, unrestricted: Vec<Word<'a>>)-> Vec<Word<'a>> { unrestricted.clone() }$/;"	f
set	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^    fn set(&\/*mut*\/self, input: I, output: O);$/;"	f
set	/Users/blaxill/code/github.com/blaxill/boo/src/memoize.rs	/^    pub fn set(&mut self, input: I, output: O) -> O {$/;"	f
shr	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn shr(self, distance: usize) -> Word<'a> {$/;"	f
sparsity	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn sparsity(&self) -> usize { self.sparsity }$/;"	f
test	/Users/blaxill/code/github.com/blaxill/boo/src/add.rs	/^mod test {$/;"	m
test	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^mod test {$/;"	m
test	/Users/blaxill/code/github.com/blaxill/boo/src/multiply.rs	/^mod test {$/;"	m
test	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^mod test {$/;"	m
to_node	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn to_node(&self, idx: NodeIdx) -> Node {$/;"	f
to_node_idx	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn to_node_idx(&mut self, node: Node) -> NodeIdx {$/;"	f
with_sparsity	/Users/blaxill/code/github.com/blaxill/boo/src/forest.rs	/^    pub fn with_sparsity(sparsity: usize) -> Forest {$/;"	f
word	/Users/blaxill/code/github.com/blaxill/boo/src/lib.rs	/^mod word;$/;"	m
word_basic	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn word_basic() {$/;"	f
word_poly	/Users/blaxill/code/github.com/blaxill/boo/src/word.rs	/^    fn word_poly() {$/;"	f
write	/Users/blaxill/code/github.com/blaxill/boo/src/node_hasher.rs	/^    fn write(&mut self, msg: &[u8]) {$/;"	f
