use super::forest::Forest;
use super::word::Word;

use std::cell::RefCell;
use std::collections::HashSet;
use std::hash::Hash;
use std::ops::BitXor;

pub trait Project {
    fn project(&self, exclude: HashSet<Self>) -> Self;
}

pub struct CompressiveSensing<X, Y> {
    sparsity: usize,
    visited_points: HashSet<X>,
    target: Y,
    initial: X,
}

impl<X, Y> CompressiveSensing<X, Y>
    where X: BitXor + Eq + Hash + Clone + Projecti,
        Y: BitXor  {
    pub fn new(sparsity: usize, initial: X, target: Y) -> CompressiveSensing<X, Y> {
        CompressiveSensing {
            sparsity: sparsity,
            visited_points: HashSet::new(),
            target: target,
            initial: initial,
        }
    }

    pub fn compressive_sensing<T, U>(
        &mut self,
        transform: T,
        local_adjoint: U) -> X
        where T: Fn(X) -> Y,
              U: Fn(X, Y) -> X {

        let mut x = self.initial.project();

        for _ in (0..100) {
            let y = transform(x.clone());
            let y_delta = y_target ^ y;
            let x_delta = local_adjoin(y_delta);
            x = (x ^ x_delta).project();
        }

        x
    }
}
/*
struct ProjectionState;

impl ProjectionState {
    fn new(sparsity: usize) -> ProjectionState { ProjectionState }
    fn restrict<'a>(&self, unrestricted: Vec<Word<'a>>)-> Vec<Word<'a>> { unrestricted.clone() }
}

fn delta<'a>(target: &Vec<Word<'a>>, current: Vec<Word<'a>>) -> Vec<Word<'a>> {
    target.iter().zip(current.iter()).map(|(lhs, rhs)| lhs ^ &rhs).collect()
}

pub fn compressive_sensing<'a, Transform, V>(
    forest: &'a RefCell<Forest>,
    transform: Transform,
    transform_inverse: Transform,
    x_n: usize,
    y_n: usize,
    y_target: Vec<Word<'a>>) -> Vec<Word<'a>>
    where Transform: Fn(Vec<Word<'a>>) -> Vec<Word<'a>> {

    let mut x: Vec<Word<'a>> = (0..x_n).map(|_| Word::new(forest)).collect();
    let mut projection = ProjectionState::new(forest.borrow().sparsity());

    for _ in (0..100) {
        let y = transform(x.clone());
        let y_delta = delta(&y_target, y);
        let x_delta = transform_inverse(y_delta);
        x = projection.restrict(delta(&x, x_delta));
    }

    x
}*/
